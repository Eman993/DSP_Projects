{"description":"Web application vulnerability","goal":"<p>Go to&nbsp;<a href=\"{{hostname}}:11110/DVWA\">{{hostname}}:11110/DVWA</a>&nbsp;and hack the site!</p>","solution":"<p>In questo laboratorio andremo ad analizzare 4 tipologie diverse di vulnerabilit&agrave; delle web application, tra cui: command injection, sql injection, cross site forgery request e file inclusion. Per ogni vulnerabilit&agrave; verr&agrave; spiegato il metodo utilizzato per sferrare l&rsquo;attacco in questione e verranno forniti i comandi utilizzati. L&rsquo;ambiente utilizzato per studiare tali tecniche &egrave; &ldquo;Damn Vulnerable Web Application (DVWA)&rdquo; : una web application che presta il fianco a numerosi attacchi. Per ogni tipologia di vulnerabilit&agrave; ci saranno tre diverse difficolt&agrave; (low, medium e high) che verranno analizzate.</p>\n<h1 style=\"height: 18px; text-align: center;\">&nbsp;1&nbsp; <strong>Command Injection<br /></strong></h1>\n<p>&nbsp;</p>\n<p>Lo scopo di questi attacchi &egrave; quello di iniettare ed eseguire comandi nelle applicazioni vulnerabili, le quali si comportano come una specie di command shell; da precisare che i comandi vengono eseguiti con i privilegi, ed all&rsquo;interno dell&rsquo;ambiente, del relativo servizio web. In generale, le web application che danno la possibilit&agrave; all&rsquo;utente di inserire un input, senza fare una validazione dello stesso, possono essere passibili di questo tipo di attacchi. La sintassi con cui vengono eseguiti i comandi varia in base al sistema operativo del web server.</p>\n<h2 style=\"text-align: center;\"><strong>1.1&nbsp; Scenario \"Easy\"</strong></h2>\n<p style=\"text-align: left;\">Lo scenario in questione, in tutte e tre le modalit&agrave;, prevede l&rsquo;inserimento di un indirizzo IP che verr&agrave; &ldquo;pingato&rdquo; dal server. Anzitutto verifichiamo che la web application in questione sia passibile di questo tipo di attacchi inserendo, dopo l&rsquo;indirizzo IP, un carattere speciale (come &ldquo;&amp;&rdquo; oppure &ldquo;&amp;&amp;&rdquo;) ed esaminiamo l&rsquo;output:</p>\n<p style=\"text-align: left;\"><img src=\"https://github.com/Eman993/Images_NS/blob/master/1%20command%20injection/1%20easy/1easy.png?raw=true\" alt=\"\" width=\"1280\" height=\"720\" /></p>\n<p style=\"text-align: left;\">Notiamo che l&rsquo;output, oltre al risultato del ping, ci restituisce il contenuto della cartella in cui si trova la web app. Questo significa che non viene fatto alcun controllo sull&rsquo;input e quindi la web application in questione &egrave; passibile di command injection. Proviamo cos&igrave; a fare una copia del file di configurazione php per visualizzarlo, con il seguente comando:</p>\n<ul>\n<li style=\"text-align: left;\">&ldquo;127.0.0.1 &amp;&amp; cp ../../config/config.inc.php new.txt&rdquo;</li>\n</ul>\n<p style=\"text-align: left;\"><img src=\"https://github.com/Eman993/Images_NS/blob/master/1%20command%20injection/1%20easy/2easy.png?raw=true\" alt=\"\" width=\"1080\" height=\"608\" /></p>\n<p style=\"text-align: left;\"><img src=\"https://github.com/Eman993/Images_NS/blob/master/1%20command%20injection/1%20easy/3%20easy.jpg?raw=true\" alt=\"\" width=\"719\" height=\"720\" /></p>\n<h2 style=\"text-align: center;\">&nbsp;<strong>1.2&nbsp; Scenario \"Medium\"<br /></strong></h2>\n<p style=\"text-align: left;\">In questo scenario alcuni caratteri speciali vengono filtrati, quindi con il precedente input non otterremmo nulla:</p>\n<p style=\"text-align: left;\"><img src=\"https://github.com/Eman993/Images_NS/blob/master/1%20command%20injection/2%20medium/2%20medium.png?raw=true\" alt=\"\" width=\"1280\" height=\"720\" /></p>\n<p style=\"text-align: left;\">Tuttavia, &egrave; ancora possibile eseguire comandi, infatti basta utilizzare altri caratteri speciali, come &ldquo;|&rdquo; :</p>\n<p style=\"text-align: left;\"><img src=\"https://github.com/Eman993/Images_NS/blob/master/1%20command%20injection/2%20medium/1%20medium.png?raw=true\" alt=\"\" width=\"1280\" height=\"720\" /></p>\n<h2 style=\"text-align: center;\"><strong>1.3&nbsp; Scenario \"High\"</strong></h2>\n<p>In questo scenario anche il precedente input non avrebbe dato frutti, visto che sarebbe stato filtrato il carattere speciale:</p>\n<p><img src=\"https://github.com/Eman993/Images_NS/blob/master/1%20command%20injection/3%20hard/2.jpg?raw=true\" alt=\"\" width=\"958\" height=\"966\" /></p>\n<p>Tuttavia, omettendo lo spazio tra l&rsquo;indirizzo ip e il carattere speciale &egrave; ancora possibile ottenere il risultato sperato, con il comando:</p>\n<ul>\n<li>&ldquo;127.0.0.1|ls&rdquo;;</li>\n</ul>\n<p><img src=\"https://github.com/Eman993/Images_NS/blob/master/1%20command%20injection/3%20hard/1hard.png?raw=true\" alt=\"\" width=\"1280\" height=\"720\" /></p>\n<h1 style=\"text-align: center;\"><strong>2&nbsp; File inclusion</strong></h1>\n<p style=\"text-align: left;\">Vulnerabilit&agrave; tipica di web application che usano script eseguiti a run time. Alcune web application permettono all&rsquo;utente di specificare l&rsquo;input che sar&agrave; usato direttamente per accedere a del codice eseguibile; in questo modo l&rsquo;attaccante pu&ograve; controllare quale file deve essere eseguito a run time. Lo scopo dell&rsquo;attaccante &egrave; far eseguire del codice non previsto; il codice pu&ograve; essere locale (Local file inclusion) oppure passato dall&rsquo;attaccante (Remote file inclusion). In questo scenario faremo eseguire del codice gi&agrave; presente sul server.</p>\n<h2 style=\"text-align: center;\"><strong>2.1 Scenario \"Easy\"</strong></h2>\n<p>Proviamo a verificare che la macchina sia passibile di tale attacco, richiedendo la pagina &ldquo;phpinfo.php&rdquo; con il seguente url:</p>\n<ul>\n<li>&ldquo;page=../../phpinfo.php&rdquo;;</li>\n</ul>\n<p><img src=\"https://github.com/Eman993/Images_NS/blob/master/2file%20inclusion/1%20easy/2easy.jpg?raw=true\" alt=\"\" width=\"1280\" height=\"720\" /></p>\n<p>Ci accorgiamo che non viene fatto alcun controllo, possiamo quindi cercare il file che ci interessa:</p>\n<p><img src=\"https://github.com/Eman993/Images_NS/blob/master/2file%20inclusion/1%20easy/3.jpg?raw=true\" alt=\"\" width=\"1280\" height=\"720\" /></p>\n<h2 style=\"text-align: center;\"><strong>2.2&nbsp; Scenario \"Medium\"</strong></h2>\n<p style=\"text-align: left;\">In questo scenario viene fatto un minimo di input validation:</p>\n<p style=\"text-align: left;\"><img src=\"https://github.com/Eman993/Images_NS/blob/master/2file%20inclusion/2%20medium/1medium.png?raw=true\" alt=\"\" width=\"602\" height=\"243\" /></p>\n<p style=\"text-align: left;\">Validazione che taglia alcuni caratteri &ldquo;sospetti&rdquo;; &egrave; tuttavia facilmente aggirabile con il seguente comando:</p>\n<ul>\n<li style=\"text-align: left;\">&ldquo;page=..././..././hackable/flags/fi.php&rdquo;;</li>\n</ul>\n<p><img src=\"https://github.com/Eman993/Images_NS/blob/master/2file%20inclusion/2%20medium/2medium.jpg?raw=true\" alt=\"\" width=\"1280\" height=\"720\" /></p>\n<h2 style=\"text-align: center;\"><strong>2.3&nbsp; Scenario \"High\"</strong></h2>\n<p>In questo scenario vengono scartate tutte le richieste che non contengono la stringa &ldquo;file&rdquo;, ad eccezione del file &ldquo;include.php&rdquo;. Questo controllo &egrave; facilmente aggirabile semplicemente inserendo la string &ldquo;file&rdquo; all&rsquo;inizio della richiesta:</p>\n<ul>\n<li>&ldquo;page=file:///etc/passwd&rdquo;;</li>\n</ul>\n<p><img src=\"https://github.com/Eman993/Images_NS/blob/master/2file%20inclusion/3%20hard/1hard.jpg?raw=true\" alt=\"\" width=\"1280\" height=\"720\" /></p>\n<h1 style=\"text-align: center;\"><strong>3&nbsp; Cross site request forgery (CSRF)</strong></h1>\n<p>Vulnerabilit&agrave; a cui sono esposti web application che ricevono richieste da un client senza particolari meccanismi per controllare se la richiesta sia stata inviata intenzionalmente oppure no. In questo caso si sfrutta la &ldquo;fiducia&rdquo; di un sito nel browser di un utente. Per sfruttare appieno questa vulnerabilit&agrave; di solito si affiancano tecniche di &ldquo;social engineering&rdquo;, atte a trovare utilizzatori di quel sito web. In particolare, se la vittima dell&rsquo;attacco &egrave; l&rsquo;amministratore della web application, questa vulnerabilit&agrave; pu&ograve; compromettere l&rsquo;utilizzo della web application stessa.</p>\n<h2 style=\"text-align: center;\"><strong>3.1&nbsp; Scenario \"Easy\"</strong></h2>\n<p>Questo scenario non prevede alcun controllo: &egrave; possibile forgiare ad arte una URL che cambi la password dell&rsquo;utente. Per nascondere il contenuto del link in questione, non facendo cos&igrave; capire alla vittima l&rsquo;azione che compir&agrave; cliccandoci sopra, &egrave; possibile utilizzare degli strumenti che ne riducano la dimensione.</p>\n<p><img src=\"https://github.com/Eman993/Images_NS/blob/master/3%20csrf/1easy/1facile.jpg?raw=true\" alt=\"\" width=\"1280\" height=\"720\" /></p>\n<h2 style=\"text-align: center;\"><strong>&nbsp;3.2&nbsp; Scenario \"Medium\"</strong></h2>\n<p>In questo scenario c&rsquo;&egrave; un controllo che serve a capire da dove proviene l&rsquo;ultima pagina richiesta; lo sviluppatore crede che se questa corrisponde al dominio corrente, allora deve venire dalla web application e pu&ograve; essere lecita. Infatti se proviamo a cliccare sul link &ldquo;forgiato ad arte&rdquo; otteniamo:</p>\n<p><img src=\"https://github.com/Eman993/Images_NS/blob/master/3%20csrf/2medium/1medium.jpg?raw=true\" alt=\"\" width=\"1280\" height=\"720\" /></p>\n<p>In questo caso c&rsquo;&egrave; bisogno di sfruttare un&rsquo;altra vulnerabilit&agrave; del sito, come ad esempio la &ldquo;stored XSS&rdquo;: questa vulnerabilit&agrave; permette di iniettare codice all&rsquo;interno del contenuto di una web app, cos&igrave; quando un utente visita la pagina infetta, lo script verr&agrave; eseguito all&rsquo;interno del suo browser, chiaramente a sua insaputa. Nell&rsquo;esempio abbiamo inserito il link per cambiare la password all&rsquo;interno del campo &ldquo;src&rdquo; del tag HTML image:</p>\n<p><img src=\"https://github.com/Eman993/Images_NS/blob/master/3%20csrf/2medium/2medium.jpg?raw=true\" alt=\"\" width=\"1280\" height=\"720\" /></p>\n<p>A questo punto l&rsquo;utente, semplicemente aprendo il link (lecito) in cui &egrave; stato iniettato il codice, far&agrave; la richiesta al link per cambiare la password con i valori scelti da noi.</p>\n<h2 style=\"text-align: center;\"><strong>3.3&nbsp; Scenario \"High\"</strong></h2>\n<p>In questo scenario &egrave; stato aggiunto un token anti-CSRF. Anche in questo caso bisogna sfruttare un&rsquo;altra vulnerabilit&agrave; del sito per poter rubare il token della vittima. In questo caso si sfrutta la vulnerabilit&agrave; &ldquo;DOM XSS&rdquo;: la web application scrive dati all&rsquo;interno del DOM senza fare una sanitizzazione appropriata. Infatti viene utilizzato uno script Javascript, precaricato sul server, che ruba il token del client e gli cambia la password (script : h<a href=\"https://github.com/Eman993/Images_NS/blob/master/3%20csrf/3hard/script.js\">ttps://github.com/Eman993/Images_NS/blob/master/3%20csrf/3hard/script.js</a>):</p>\n<p><img src=\"https://github.com/Eman993/Images_NS/blob/master/3%20csrf/3hard/1hard.jpg?raw=true\" alt=\"\" width=\"1280\" height=\"720\" /></p>\n<p><img src=\"https://github.com/Eman993/Images_NS/blob/master/3%20csrf/3hard/3hard.jpg?raw=true\" alt=\"\" width=\"1280\" height=\"720\" /></p>\n<h1 style=\"text-align: center;\"><strong>4&nbsp; SQL Injection</strong></h1>\n<p>Questo attacco consiste nell&rsquo;iniezione di query SQL, tramite l&rsquo;input della web app, dal client al server. Viene utilizzato per leggere dati sensibili dal database, modificarli, eseguire operazioni da amministratore sul database, prendere il contenuto di un file sul DBMS system e, in alcuni casi, mandare comandi al sistema operativo del server. In questo caso andremo a rubare dati sensibili (username e password) degli utenti registrati all&rsquo;interno del database.</p>\n<h2 style=\"text-align: center;\"><strong>4.1&nbsp; Scenario \"Easy\"</strong></h2>\n<p>Anzitutto controlliamo la presenza della vulnerabilit&agrave; scrivendo la string: &ldquo;1&rsquo; &rdquo;:</p>\n<p><img src=\"https://github.com/Eman993/Images_NS/blob/master/4sqli/1easy/2easy.jpg?raw=true\" alt=\"\" width=\"1280\" height=\"720\" /></p>\n<p>Questo &egrave; indice che la web application &egrave; vulnerabile a tali tipi di attacchi. Inseriamo uno statement sempre vero (&ldquo;1=1&rdquo;) e commentiamo le linee successive con &ldquo;#&rdquo;:</p>\n<p><img src=\"https://github.com/Eman993/Images_NS/blob/master/4sqli/1easy/3easy.jpg?raw=true\" alt=\"\" width=\"1280\" height=\"720\" /></p>\n<p>A questo punto cerchiamo dati sensibili all&rsquo;interno della tabella &ldquo;INFORMATION_SCHEMA.TABLES&rdquo;(query nell&rsquo;immagine):</p>\n<p><img src=\"https://github.com/Eman993/Images_NS/blob/master/4sqli/1easy/5.jpg?raw=true\" alt=\"\" width=\"1280\" height=\"720\" /></p>\n<p>Abbiamo scoperto che la tabella degli utenti semplicemente si chiama &ldquo;users&rdquo;; possiamo cos&igrave; fare una query per vedere username e password memorizzate (query nell'immagine):</p>\n<p><img src=\"https://github.com/Eman993/Images_NS/blob/master/4sqli/1easy/6.jpg?raw=true\" alt=\"\" width=\"1280\" height=\"720\" /></p>\n<p>Le password non sono memorizzate in chiaro, abbiamo bisogno di decriptarne il contenuto con un &ldquo;MD5 hash decrypter&rdquo;, che si pu&ograve; trovare tranquillamente online:</p>\n<p><img src=\"https://github.com/Eman993/Images_NS/blob/master/4sqli/1easy/7.jpg?raw=true\" alt=\"\" width=\"1280\" height=\"720\" /></p>\n<p>Ecco la password per l&rsquo;utente &ldquo;admin&rdquo;.</p>\n<h2 style=\"text-align: center;\"><strong>4.2&nbsp; Scenario \"Medium\"</strong></h2>\n<p>In questo scenario abbiamo una funzione \"mysqli_real_escape_string\" che fa l'escape dei caratteri speciali nella stringa che viene usata per lo statement SQL:</p>\n<p><img src=\"https://github.com/Eman993/Images_NS/blob/master/4sqli/2medium/1.jpg?raw=true\" alt=\"\" width=\"1280\" height=\"720\" /></p>\n<p>Perci&ograve; non possono essere fatte richieste in maniera diretta, perch&eacute; l&rsquo;input viene filtrato; cos&igrave; si cerca di manomettere i dati che vengono inviati tramite la post http fatta al server. Per fare questo si pu&ograve; utilizzare \"Burp\", il quale intercetta le richieste prima che vengano effettivamente inviate, dando la possibilit&agrave; cos&igrave; di manometterle:</p>\n<p><img src=\"https://github.com/Eman993/Images_NS/blob/master/4sqli/2medium/2.jpg?raw=true\" alt=\"\" width=\"1280\" height=\"720\" /></p>\n<p>In questo modo otteniamo la pagina di errore precedente e, similmente al caso precendente, riusciamo ad ottenere i dati sensibili:</p>\n<p><img src=\"https://github.com/Eman993/Images_NS/blob/master/4sqli/2medium/8.jpg?raw=true\" alt=\"\" width=\"1280\" height=\"720\" /></p>\n<h2 style=\"text-align: center;\"><strong>4.3&nbsp; Scenario \"High\"</strong></h2>\n<p>Questo scenario &egrave; molto simile a quello facile, solo che l&rsquo;attaccante invia i dati tramite una variabile di sessione usando una pagina differente, piuttosto che fare una richiesta get diretta. Le query fatte sono le stesse di quelle fatte in precedenza:</p>\n<p><img src=\"https://github.com/Eman993/Images_NS/blob/master/4sqli/3hard/1.jpg?raw=true\" alt=\"\" width=\"1280\" height=\"720\" /></p>\n<p><img src=\"https://github.com/Eman993/Images_NS/blob/master/4sqli/3hard/5.jpg?raw=true\" alt=\"\" width=\"1280\" height=\"720\" /></p>","author":"Emanuele"}
